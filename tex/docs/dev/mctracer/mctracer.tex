\subsection{Call hierarchy: Memory access}

\tikzstyle{accarrw} = [draw,->,thick, shorten <=10, shorten >=10]
\tikzstyle{trmain} = [draw,fill=red!50]
\tikzstyle{trsim} = [draw,fill=green!50]
\tikzstyle{trstats} = [draw,fill=blue!50]
\tikzstyle{trseq} = [draw,fill=purple!50]
\begin{tikzpicture}[scale=1]
	\node [trmain]  (instrument) at (0,2.5) {\fun{mt\_instrument}};
	\node [trmain]  (fE) at (0,1.5)         {\fun{flushEvents}};
	\node [cloud,draw,aspect=2,cloud puffs=9] (magic) at (0,0.25) {magic};
	\node [trsim]   (load) at (2,-1)        {\fun{ssim\_load}} node [trsim] (store) at (-2,-1) {\fun{ssim\_store}};
	\node [trstats] (ums)  at (0,-2)        {\fun{update\_matrix\_stats}};
	\node [trstats] (fm)   at (5,-1.5)      {\fun{find\_matrix}};
	\node [trsim]   (cr)   at (5,-2.5)      {\fun{cache\_ref}};
	\node [trsim]   (csr)  at (6,-3.5)      {\fun{cache\_setref}};
	\node [trstats] (umas) at (0,-3)        {\fun{update\_matrix\_access\_stats}};
	\node [trseq]   (umps) at (0,-4)        {\fun{update\_matrix\_pattern\_stats}};
	\node [trseq]   (ppb)  at (0,-6)        {\fun{process\_pattern\_buffer}};
	\node [trseq]   (sec)  at (-4.5,-8)     {\fun{subpatttern\_elimination\_check}};
	\node [trseq]   (mpf)  at (-5.25,-7)    {\fun{mark\_pattern\_findings}};
	\node [trseq]   (dap)  at (2.5,-8)      {\fun{delete\_access\_pattern}};
	\node [trseq]   (fnp)  at (0,-7)        {\fun{find\_new\_patterns}};
	\node [trseq]   (fs)   at (5.1,-7)      {\fun{find\_sequences}};
	\node [trseq]   (rapa) at (5.1,-9)      {\fun{reallocate\_sequencearray}};
	\foreach \s/\e in {instrument/fE, load/ums, store/ums, ums/fm, ums/cr, cr/csr, ums/umas, umas/umps, ppb/mpf, ppb/fnp, ppb/fs, fs/rapa}{
		\path [->,thick,draw] (\s) -- (\e);
	}
	\foreach \s/\e in {sec/mpf, sec/dap, fnp/sec, fnp/dap, fE/magic.north east, fE/magic.north west, magic.south west/store, magic.south east/load}{
		\path [->,thick,draw,dashed] (\s) -- (\e);
	}
	\draw (-7.25,-8.5) rectangle (-1,-12.75);
	\path [->,thick,draw,dashed] (umps) -- (ppb) node [midway,right,draw,xshift=0.5em] {When the buffer is full};
	\path [->,thick,draw]        (-7,-9) -- (-6,-9) node [right] {Call, always};
	\path [->,thick,draw,dashed] (-7,-9.5) -- (-6,-9.5) node [right] {Call, conditional};
	\node [anchor=west,trmain]  at(-7,-10.5)   {Method from \texttt{tr\_main.c}};
	\node [anchor=west,trsim]   at(-7,-11.1) {Method from \texttt{tr\_sim.c}};
	\node [anchor=west,trstats] at(-7,-11.7) {Method from \texttt{tr\_stats.c}};
	\node [anchor=west,trseq]   at(-7,-12.3) {Method from \texttt{tr\_sequences.c}};
\end{tikzpicture}
\newpage
\subsection{Explanation by Methods}

\begin{description} %the plan is to add a longer description to the more complex ones of these
\item[\fun{cache\_ref()}] Maps an access to one or two cache sets. Queries \fun{cache\_setref} to return hit or miss.
\item[\fun{cache\_setref()}] For a given cache set and adress: Updates the set and returns hit or miss;
\item[\fun{ssim\_load()}] Proxy function for calling \fun{update\_matrix\_stats(..., MATRIX\_LOAD)}
\item[\fun{ssim\_store()}] Proxy function for calling \fun{update\_matrix\_stats(..., MATRIX\_STORE)}
\item[\fun{find\_matrix()}] Finds and returns a pointer to the matrix containing a given memory address
\item[\fun{update\_matrix\_stats(Addr addr, SizeT size, char type)}] For the given address: Updates the absolute position
    access stats. It does so by retrieving a reference to the matrix containing the given address and
    querying \fun{cache\_ref} to determine whether the access was a cache hit or miss. Depending on the outcome
    of the last operation, the hit or miss counter of the matrix entry referenced by the given address will be incremented.
    Furthermore the method makes a call to \fun{update\_matrix\_access\_stats()} to gather relative access statistics.
\item[\fun{update\_matrix\_access\_stats(traced\_matrix* matr, ..., int is\_hit, Addr addr)}] For
    the given matrix and absolute access: updates the relative access statistics. Therefore it keeps track of the last most
    access (address) to the matrix and calculates the difference in the index position to the current access. The
    difference is referred to as a relative access method and explicitly stored as such. In case the particular access
    method did not yet exist it will be newly created. Lastly the hit or miss counter for the access method is incremented
    by one.
\item[\fun{update\_matrix\_pattern\_stats()}] Fills the buffer for pattern recognition with one relative access per call. Invokes \fun{process\_pattern\_buffer} when full.
\item[\fun{process\_pattern\_buffer()}] Management function for pattern/sequence recognition. Keeps a buffer stating which access belongs to which pattern. Invokes marking existing patterns in that buffer, finding new patterns and the statistics on that buffer
\item[\fun{process\_pattern\_buffer()}] For a matrix, one of it's patterns and it's access buffer: Marks each location that pattern occurs
\item[\fun{mark\_pattern\_findings()}] For a matrix and it's access buffer: Tries to find non-marked, short, repeating patterns. Avoids/deletes patterns being parts of other patterns
\item[\fun{subpatttern\_elimination\_check()}] For a pattern: Eliminates it, if it is part ("subpattern") of any other pattern of that matrix
\item[\fun{delete\_access\_pattern()}] Eleminates the given pattern. Makes sure to clean all remains
\item[\fun{find\_sequences()}] The workhorse of the pattern/sequence statistics. Counts hits and misses for the accesses in the patterns. Sums up the length of repetitions of paterns as sequences
\item[\fun{reallocate\_sequencearray()}] Helper to make sure enough space is reserved for the current number of sequences

\end{description}

\subsection{Writing to file}

Finally all of the collected data is written to a file on disk. We use the etis format as specified in the next section. The process is straightforward with the only noteworthy detail being that relative accesses and sequences are sorted by hits and misses or occurences respectively.
