From 272387e46cefc9b7d70986c514d79319059b6574 Mon Sep 17 00:00:00 2001
From: Josef Weidendorfer <Josef.Weidendorfer@gmx.de>
Date: Mon, 7 Nov 2011 11:45:39 +0100
Subject: [PATCH] Add McTracer using shared memory event channel

---
 Makefile.am                    |    1 +
 autogen.sh                     |   17 ++
 configure.in                   |    2 +
 mctracer/Makefile.am           |   62 +++++
 mctracer/docs/tr-manual.xml    |   13 +
 mctracer/mctracer.h            |  115 ++++++++
 mctracer/shm_common.h          |   51 ++++
 mctracer/shm_consumer.c        |  306 ++++++++++++++++++++++
 mctracer/shm_consumer.h        |   24 ++
 mctracer/shm_vgprod.c          |  367 ++++++++++++++++++++++++++
 mctracer/shm_vgprod.h          |  144 ++++++++++
 mctracer/tests/Makefile.am     |    3 +
 mctracer/tests/filter_stderr   |   14 +
 mctracer/tests/true.stderr.exp |   20 ++
 mctracer/tests/true.vgtest     |    1 +
 mctracer/tr_consumer.c         |   66 +++++
 mctracer/tr_main.c             |  567 ++++++++++++++++++++++++++++++++++++++++
 mctracer/tr_shmevents.h        |   49 ++++
 18 files changed, 1822 insertions(+), 0 deletions(-)
 create mode 100755 autogen.sh
 create mode 100644 mctracer/Makefile.am
 create mode 100644 mctracer/docs/tr-manual.xml
 create mode 100644 mctracer/mctracer.h
 create mode 100644 mctracer/shm_common.h
 create mode 100644 mctracer/shm_consumer.c
 create mode 100644 mctracer/shm_consumer.h
 create mode 100644 mctracer/shm_vgprod.c
 create mode 100644 mctracer/shm_vgprod.h
 create mode 100644 mctracer/tests/Makefile.am
 create mode 100644 mctracer/tests/filter_stderr
 create mode 100644 mctracer/tests/true.stderr.exp
 create mode 100644 mctracer/tests/true.vgtest
 create mode 100644 mctracer/tr_consumer.c
 create mode 100644 mctracer/tr_main.c
 create mode 100644 mctracer/tr_shmevents.h

diff --git a/Makefile.am b/Makefile.am
index fadc32a..a3173fa 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -8,6 +8,7 @@ TOOLS =		memcheck \
 		callgrind \
 		massif \
 		lackey \
+		mctracer \
 		none \
 		helgrind \
 		drd
diff --git a/autogen.sh b/autogen.sh
new file mode 100755
index 0000000..117462c
--- /dev/null
+++ b/autogen.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+run ()
+{
+    echo "running: $*"
+    eval $*
+
+    if test $? != 0 ; then
+	echo "error: while running '$*'"
+	exit 1
+    fi
+}
+
+run aclocal
+run autoheader
+run automake -a
+run autoconf
diff --git a/configure.in b/configure.in
index c04cabe..5b3e01c 100644
--- a/configure.in
+++ b/configure.in
@@ -1946,6 +1946,8 @@ AC_CONFIG_FILES([
    massif/ms_print
    lackey/Makefile
    lackey/tests/Makefile
+   mctracer/Makefile
+   mctracer/tests/Makefile
    none/Makefile
    none/tests/Makefile
    none/tests/amd64/Makefile
diff --git a/mctracer/Makefile.am b/mctracer/Makefile.am
new file mode 100644
index 0000000..07de94f
--- /dev/null
+++ b/mctracer/Makefile.am
@@ -0,0 +1,62 @@
+include $(top_srcdir)/Makefile.tool.am
+
+EXTRA_DIST = docs/tr-manual.xml
+
+bin_PROGRAMS = tr-consumer
+
+tr_consumer_SOURCES = tr_consumer.c shm_consumer.c
+tr_consumer_CFLAGS  = $(AM_CFLAGS_PRI)
+tr_consumer_LDFLAGS = $(AM_CFLAGS_PRI)
+
+#----------------------------------------------------------------------------
+# mctracer-<platform>
+#----------------------------------------------------------------------------
+
+noinst_PROGRAMS  = mctracer-@VGCONF_ARCH_PRI@-@VGCONF_OS@
+if VGCONF_HAVE_PLATFORM_SEC
+noinst_PROGRAMS += mctracer-@VGCONF_ARCH_SEC@-@VGCONF_OS@
+endif
+
+MCTRACER_SOURCES_COMMON = tr_main.c shm_vgprod.c
+
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_SOURCES      = \
+	$(MCTRACER_SOURCES_COMMON)
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_CPPFLAGS     = \
+	$(AM_CPPFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_CFLAGS       = \
+	$(AM_CFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_DEPENDENCIES = \
+	$(TOOL_DEPENDENCIES_@VGCONF_PLATFORM_PRI_CAPS@)
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LDADD        = \
+	$(TOOL_LDADD_@VGCONF_PLATFORM_PRI_CAPS@)
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LDFLAGS      = \
+	$(TOOL_LDFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LINK = \
+	$(top_builddir)/coregrind/link_tool_exe_@VGCONF_OS@ \
+	@VALT_LOAD_ADDRESS_PRI@ \
+	$(LINK) \
+	$(mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_CFLAGS) \
+	$(mctracer_@VGCONF_ARCH_PRI@_@VGCONF_OS@_LDFLAGS)
+
+if VGCONF_HAVE_PLATFORM_SEC
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_SOURCES      = \
+	$(MCTRACER_SOURCES_COMMON)
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_CPPFLAGS     = \
+	$(AM_CPPFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_CFLAGS       = \
+	$(AM_CFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_DEPENDENCIES = \
+	$(TOOL_DEPENDENCIES_@VGCONF_PLATFORM_SEC_CAPS@)
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LDADD        = \
+	$(TOOL_LDADD_@VGCONF_PLATFORM_SEC_CAPS@)
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LDFLAGS      = \
+	$(TOOL_LDFLAGS_@VGCONF_PLATFORM_SEC_CAPS@)
+mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LINK = \
+	$(top_builddir)/coregrind/link_tool_exe_@VGCONF_OS@ \
+	@VALT_LOAD_ADDRESS_SEC@ \
+	$(LINK) \
+	$(mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_CFLAGS) \
+	$(mctracer_@VGCONF_ARCH_SEC@_@VGCONF_OS@_LDFLAGS)
+endif
+
+
diff --git a/mctracer/docs/tr-manual.xml b/mctracer/docs/tr-manual.xml
new file mode 100644
index 0000000..ce6c5a3
--- /dev/null
+++ b/mctracer/docs/tr-manual.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0"?> <!-- -*- sgml -*- -->
+<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
+  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
+
+<chapter id="tr-manual" xreflabel="McTracer">
+
+<title>McTracer: data access tracer</title>
+
+<para>To use this tool, you must specify
+<option>--tool=mctracer</option> on the Valgrind
+command line.</para>
+
+</chapter>
diff --git a/mctracer/mctracer.h b/mctracer/mctracer.h
new file mode 100644
index 0000000..bd9c388
--- /dev/null
+++ b/mctracer/mctracer.h
@@ -0,0 +1,115 @@
+/*
+   ----------------------------------------------------------------
+
+   Notice that the following BSD-style license applies to this one
+   file (mctracer.h) only.  The rest of Valgrind is licensed under the
+   terms of the GNU General Public License, version 2, unless
+   otherwise indicated.  See the COPYING file in the source
+   distribution for details.
+
+   ----------------------------------------------------------------
+
+   This file is part of McTracer, a Valgrind tool for memory tracing.
+   Written for ETI @ TUM, McVisCas2010, (C) 2010 Josef Weidendorfer.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+   2. The origin of this software must not be misrepresented; you must
+      not claim that you wrote the original software.  If you use this
+      software in a product, an acknowledgment in the product
+      documentation would be appreciated but is not required.
+
+   3. Altered source versions must be plainly marked as such, and must
+      not be misrepresented as being the original software.
+
+   4. The name of the author may not be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+   ----------------------------------------------------------------
+
+   Notice that the above BSD-style license applies to this one file
+   (callgrind.h) only.  The entire rest of Valgrind is licensed under
+   the terms of the GNU General Public License, version 2.  See the
+   COPYING file in the source distribution for details.
+
+   ----------------------------------------------------------------
+*/
+
+#ifndef __MCTRACER_H
+#define __MCTRACER_H
+
+#include "valgrind.h"
+
+/* !! ABIWARNING !! ABIWARNING !! ABIWARNING !! ABIWARNING !!
+   This enum comprises an ABI exported by Valgrind to programs
+   which use client requests.  DO NOT CHANGE THE ORDER OF THESE
+   ENTRIES, NOR DELETE ANY -- add new ones at the end.
+ */
+
+typedef
+   enum {
+      VG_USERREQ__PRINT = VG_USERREQ_TOOL_BASE('M','T'),
+      VG_USERREQ__PRINTA,
+      VG_USERREQ__PRINTU,
+      VG_USERREQ__TRACING
+   } Vg_McTracerClientRequest;
+
+/* Print a string into the trace, prefixed by "P  " */
+#define MCTRACER_PRINT(str)              				\
+   {unsigned int _qzz_res;                                              \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                             \
+                            VG_USERREQ__PRINT,                          \
+                            str, 0, 0, 0, 0);                           \
+   }
+
+/* Print a string and a hex address into the trace, prefixed by "PA " */
+#define MCTRACER_PRINTA(addr)             				\
+   {unsigned int _qzz_res;                                              \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                             \
+                            VG_USERREQ__PRINTA,                         \
+			       addr, 0, 0, 0, 0);                        \
+   }
+
+/* Print a string and an unsigned into the trace, prefixed by "PU " */
+#define MCTRACER_PRINTU(uval)             				\
+   {unsigned int _qzz_res;                                              \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                             \
+                            VG_USERREQ__PRINTU,                         \
+			       uval, 0, 0, 0, 0);			\
+   }
+
+/* Switch tracing on */
+#define MCTRACER_TRACING_ON                 				\
+   {unsigned int _qzz_res;                                              \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                             \
+                            VG_USERREQ__TRACING,                        \
+                            1, 0, 0, 0, 0);                             \
+   }
+
+/* Switch tracing off */
+#define MCTRACER_TRACING_OFF                 				\
+   {unsigned int _qzz_res;                                              \
+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                             \
+                            VG_USERREQ__TRACING,                        \
+                            0, 0, 0, 0, 0);                             \
+   }
+
+#endif /* __MCTRACER_H */
diff --git a/mctracer/shm_common.h b/mctracer/shm_common.h
new file mode 100644
index 0000000..4711678
--- /dev/null
+++ b/mctracer/shm_common.h
@@ -0,0 +1,51 @@
+/* Shared memory event bridge
+ * (C) 2011, Josef Weidendorfer
+ *
+ * Internal SHM file structure common for both producer and consumer side
+ */
+
+#ifndef SHMPRIV_H
+#define SHMPRIV_H
+
+/* 7 chars */
+#define SHM_MAGIC "EVBRG-1"
+#define SHM_NAME  "event_bridge"
+#define SHMSIZE (1<<20)
+
+typedef struct {
+  char magic[8];
+  int  size;
+  char producer_64bit;
+  char producer_initialized;
+  char reserved1;
+  char consumer_attached;
+
+  struct {
+    int offset;
+    int size;
+    char name[8];
+  } seg[15];
+} shm_header;
+
+/* Chunked ring buffers
+ *
+ * Format:
+ * - 64 byte header (rb_header)
+ * - chunk state array: for each chunk: 1 byte state, 63 byte padding (1 cacheline)
+ * - for each chunk: payload buffer, aligned to 64 bytes
+ *   if chunk is full, 4 first bytes of payload give used size
+ */
+
+#define RBSTATE_EMPTY   0
+#define RBSTATE_FULL    1
+#define RBSTATE_FULLEND 2
+
+typedef struct {
+  int chunk_count;
+  int chunk_size;
+  int state0_offset;    /* offset in segment to chunk state array */
+  int buffer0_offset;   /* <elem_size> bytes per element */
+} rb_header;
+
+
+#endif /* SHMPRIV_H */
diff --git a/mctracer/shm_consumer.c b/mctracer/shm_consumer.c
new file mode 100644
index 0000000..bd34c6b
--- /dev/null
+++ b/mctracer/shm_consumer.c
@@ -0,0 +1,306 @@
+/* Shared memory event bridge (consumer side)
+ * Allows multiple, chunked ring buffers
+ *
+ * (C) 2011, Josef Weidendorfer
+ */
+
+#include "shm_consumer.h"
+#include "shm_common.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <assert.h>
+#include <stdarg.h>
+
+struct _shm_buf {
+    shm_header* h;
+    char file[20];
+};
+
+struct _rb_chunk {
+  shm_rb* rb;
+  volatile unsigned char* state;
+  unsigned char* buffer;
+  rb_chunk* next;
+
+  int used; /* >0 if reading the chunk */
+  int read; /* read pointer */
+};
+
+struct _shm_rb {
+  rb_header* header;
+  rb_chunk* first;
+  rb_chunk chunk[0];
+};
+
+/*--------------------------------------------------------------
+ * Time measurement helpers
+ */
+
+double wtime(void);
+
+/* enables use of rdtsc, assume 2.4 GHz */
+#define TSCRATE 2400
+
+static inline
+unsigned long long rdtsc_read(void)
+{
+   unsigned long long val;
+
+#ifdef __amd64__
+   /* x86 64bit specific */
+   unsigned int _hi,_lo;
+   asm volatile("rdtsc":"=a"(_lo),"=d"(_hi));
+   val = ((unsigned long long int)_hi << 32) | _lo;
+#else
+   /* x86 32bit specific */
+   asm volatile("rdtsc" : "=A" (val));
+#endif
+   return val;
+}
+
+double wtime(void)
+{
+#ifdef TSCRATE
+   /* Use tsc counter */
+   return (double) rdtsc_read() / (double) TSCRATE / 1000000.0;
+#else
+    struct timeval tv;
+    double res = 0.0;
+
+    gettimeofday(&tv, 0);
+    res = (double) tv.tv_sec;
+    res += (double) tv.tv_usec / 1000000.0;
+
+    return res;
+#endif
+}
+
+/*--------------------------------------------------------------
+ * Event bridge functions
+ */
+
+#define VERBOSE 0
+
+/* statistics */
+static double attach_time;
+static unsigned chunks_consumed = 0;
+static unsigned long long events_consumed = 0;
+static unsigned long long bytes_consumed = 0;
+static double wait_time = 0.0;
+
+static int producer_pid = 0;
+static int verbose = 0;
+
+shm_buf* attach(int pid)
+{
+    int fd;
+    shm_buf* b;
+    void* addr;
+
+    b = (shm_buf*) malloc(sizeof(shm_buf));
+    if (!b) return 0;
+
+    sprintf(b->file, "/tmp/%s.%d", SHM_NAME, pid);
+    fd = open(b->file, O_RDWR);
+    if (fd<0) {
+	free(b);
+	return 0;
+    }
+
+    addr = mmap(0, SHMSIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (addr == (void*)-1) {
+	free(b);
+	return 0;
+    }
+    close(fd);
+    unlink(b->file);
+
+    producer_pid = pid;
+
+    b->h = (shm_header*) addr;
+    shm_printf("Event consumer: attaching to '%s'.\n", b->file);
+    if (b->h->producer_initialized == 0) {
+	volatile char* w = &(b->h->producer_initialized);
+	shm_printf("Waiting for producer to finish initialization...\n");
+	while(!*w);
+	shm_printf("Done.\n");
+    }
+
+    // check for same arch width in producer and consumer
+    assert( b->h->producer_64bit ? (sizeof(long)==8) : (sizeof(long)==4));
+
+    b->h->consumer_attached = 1;
+
+    attach_time = wtime();
+
+    return b;
+}
+
+shm_buf* shm_init(int argc, char* argv[])
+{
+  int pid = 0;
+  shm_buf* b;
+  int arg;
+
+  for(arg=1; arg<argc; arg++) {
+    if (argv[arg][0] == '-') {
+      if (argv[arg][1] == 'v')
+	verbose++;
+    }
+    else
+      pid = atoi(argv[arg]);
+  }
+
+  if (pid==0) {
+    printf("Usage: %s [-v] <pid>\n", argv[0]);
+    exit(1);
+  }
+
+  b = attach(pid);
+  return b;
+}
+
+void shm_printf(const char *format, ...)
+{
+    char myformat[512];
+    va_list vargs;
+
+    if (verbose == 0) return;
+    va_start(vargs, format);
+    sprintf(myformat, "++%d++ %s", producer_pid, format);
+    vfprintf(stderr, myformat, vargs);
+    va_end(vargs);
+}
+
+shm_rb* open_rb(shm_buf* b, char* name)
+{
+    int s, i;
+    rb_header* h;
+    shm_rb* rb;
+    char* seg;
+
+    if (!b) return 0;
+    for(s=0;s<15;s++)
+	if ((b->h->seg[s].offset >0) &&
+	    (strcmp(name, b->h->seg[s].name)==0)) break;
+    if (s==15) return 0;
+
+    seg = (char*)(b->h) + b->h->seg[s].offset;
+    h = (rb_header*) seg;
+
+    rb = (shm_rb*) malloc(sizeof(shm_rb) + h->chunk_count * sizeof(rb_chunk));
+    if (!rb) return 0;
+
+    rb->header = h;
+    rb->first = &(rb->chunk[0]);
+    for(i=0;i<h->chunk_count;i++) {
+      rb->chunk[i].rb = rb;
+      rb->chunk[i].state = & seg[64 + 64*i];
+      rb->chunk[i].buffer = & seg[64*(h->chunk_count+1) + h->chunk_size * i];
+      rb->chunk[i].used = -1;
+      rb->chunk[i].read = 0;
+      rb->chunk[i].next = &(rb->chunk[ (i<h->chunk_count-1) ? i+1 : 0]);
+    }
+
+    shm_printf("Event consumer: seg '%s' (at 0x%x, size %d): ring with %d chunks a %d bytes.\n",
+	   name, b->h->seg[s].offset, b->h->seg[s].size,
+	   h->chunk_count, h->chunk_size);
+
+    return rb;
+}
+
+static void open_chunk(rb_chunk** cPtr)
+{
+    rb_chunk* c = *cPtr;
+
+    if (*(c->state) == RBSTATE_EMPTY) {
+	double t;
+
+#if VERBOSE
+	unsigned char* seg = (char*) c->rb->header;
+
+	printf("Waiting for chunk at 0x%x (state at 0x%x) to be filled.\n",
+	       (int)(c->buffer - seg), (int)(c->state - seg));
+#endif
+
+	t = wtime();
+	while(*(c->state) == RBSTATE_EMPTY) {}
+	wait_time += wtime() - t;
+    }
+
+    c->used = *(int*)c->buffer;
+    c->read = 4;
+
+#if VERBOSE
+    printf("Opened chunk at 0x%x for reading (has %d bytes).\n",
+	   (int)(c->buffer - (char*) c->rb->header), c->used);
+#endif
+
+    assert(c->used <= c->rb->header->chunk_size);
+}
+
+rb_chunk* open_first(shm_rb* rb)
+{
+    rb_chunk* c = rb->first;
+    open_chunk(&c);
+
+    return c;
+}
+
+rb_chunk* finish_chunk(rb_chunk* c, rb_chunk** cPtr)
+{
+  assert(c->read == c->used);
+  chunks_consumed++;
+  bytes_consumed += c->read;
+  if (*(c->state) == RBSTATE_FULLEND) {
+    double t = wtime() - attach_time;
+    double tt = t - wait_time;
+    shm_printf("Event consumer: statistics\n");
+    shm_printf("  run %.3f secs since attaching (%.3f secs waiting = %.2f%%)\n",
+	       t, wait_time, wait_time/t*100.0);
+    shm_printf("  consumed %d chunks, %lld events, %lld bytes\n",
+	       chunks_consumed, events_consumed, bytes_consumed);
+    shm_printf("  troughput %.3f MEv/s, %.3f MB/s (without waiting %.1f MEv/s, %.1f MB/s)\n",
+	   (double) events_consumed / t / 1000000.0,
+	   (double) bytes_consumed / t / 1000000.0,
+	   (double) events_consumed / tt / 1000000.0,
+	   (double) bytes_consumed / tt / 1000000.0 );
+    return 0;
+  }
+  *(c->state) = RBSTATE_EMPTY;
+  c = c->next;
+  *cPtr = c;
+  open_chunk(cPtr);
+
+  return c;
+}
+
+unsigned char* next_event(rb_chunk** cPtr)
+{
+    rb_chunk* c = *cPtr;
+    unsigned char* e;
+
+    if (c->read >= c->used) {
+      c = finish_chunk(c, cPtr);
+      if (!c) return 0;
+    }
+    e = c->buffer + c->read;
+    events_consumed++;
+
+#if VERBOSE
+    printf("Got event %d (len %d) at %d/%d of chunk at 0x%x.\n",
+	   (int)e[1], (int)e[0], c->read, c->used,
+	   (int)(c->buffer - (unsigned char*) c->rb->header));
+#endif
+
+    c->read += (int)e[0];
+    return e;
+}
+
diff --git a/mctracer/shm_consumer.h b/mctracer/shm_consumer.h
new file mode 100644
index 0000000..9cfdb6f
--- /dev/null
+++ b/mctracer/shm_consumer.h
@@ -0,0 +1,24 @@
+/* Shared memory event bridge (consumer side)
+ * Allows multiple, chunked ring buffers
+ *
+ * (C) 2011, Josef Weidendorfer
+ */
+
+#ifndef SHM_CONSUMER_H
+#define SHM_CONSUMER_H
+
+typedef struct _shm_buf shm_buf;
+typedef struct _rb_chunk rb_chunk;
+typedef struct _shm_rb shm_rb;
+
+shm_buf* attach(int pid);
+shm_rb* open_rb(shm_buf*, char* name);
+rb_chunk* open_first(shm_rb*);
+rb_chunk* finish_chunk(rb_chunk* c, rb_chunk** cPtr);
+unsigned char* next_event(rb_chunk** cPtr);
+
+shm_buf* shm_init(int argc, char* argv[]); // parses <pid> arg and attaches
+
+void shm_printf(const char *format, ...);
+
+#endif
diff --git a/mctracer/shm_vgprod.c b/mctracer/shm_vgprod.c
new file mode 100644
index 0000000..7061797
--- /dev/null
+++ b/mctracer/shm_vgprod.c
@@ -0,0 +1,367 @@
+/* Shared memory event bridge (Valgrind side)
+ * Allows multiple, chunked ring buffers
+ *
+ * (C) 2011, Josef Weidendorfer
+ */
+
+#include "pub_tool_basics.h"
+#include "pub_tool_vki.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_libcassert.h"
+#include "pub_tool_libcproc.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_libcfile.h"
+#include "pub_tool_aspacemgr.h"
+#include "pub_tool_mallocfree.h"
+#include "pub_tool_options.h"
+
+#include "shm_vgprod.h"
+
+/* to be exported by aspacemgr... */
+extern SysRes VG_(am_shared_mmap_file_float_valgrind)
+( SizeT length, UInt prot, Int fd, Off64T offset );
+
+   
+static char* shmaddr = 0;
+static shm_header* shmh = 0;
+static Int shmused;
+static char shmfile[20];
+
+/*--------------------------------------------------------------
+ * Time measurement helpers
+ */
+
+double wtime(void);
+
+/* enables use of rdtsc, assume 2.4 GHz */
+#define TSCRATE 2400
+
+static inline
+unsigned long long rdtsc_read(void)
+{
+   unsigned long long val;
+
+#ifdef __amd64__
+   /* x86 64bit specific */
+   unsigned int _hi,_lo;
+   asm volatile("rdtsc":"=a"(_lo),"=d"(_hi));
+   val = ((unsigned long long int)_hi << 32) | _lo;
+#else
+   /* x86 32bit specific */
+   asm volatile("rdtsc" : "=A" (val));
+#endif
+   return val;
+}
+
+double wtime(void)
+{
+#ifdef TSCRATE
+   /* Use tsc counter */
+   return (double) rdtsc_read() / (double) TSCRATE / 1000000.0;
+#else
+    struct timeval tv;
+    double res = 0.0;
+
+    gettimeofday(&tv, 0);
+    res = (double) tv.tv_sec;
+    res += (double) tv.tv_usec / 1000000.0;
+
+    return res;
+#endif
+}
+
+/*--------------------------------------------------------------
+ * Event bridge functions
+ */
+
+/* statistics */
+double attach_time;
+double wait_time = 0.0;
+
+char* shm_init(void)
+{
+    Char* magic = SHM_MAGIC;
+    Char buf[4];
+    SysRes res;
+    int fd, i;
+
+    if (shmaddr) return shmaddr;
+
+    if (sizeof(shm_header) != 256)
+      VG_(tool_panic)("SHM header size wrong.");
+
+    VG_(sprintf)(shmfile,"/tmp/%s.%d", SHM_NAME, VG_(getpid)());
+    res = VG_(open)(shmfile,
+                   VKI_O_CREAT|VKI_O_RDWR|VKI_O_TRUNC,
+		   VKI_S_IRUSR|VKI_S_IWUSR);
+    if (sr_isError(res)) return 0;
+    fd = (Int) sr_Res(res);
+    VG_(lseek)(fd, SHMSIZE-1, VKI_SEEK_SET);
+    buf[0] = 0;
+    VG_(write)(fd, buf , 1);
+    
+    res = VG_(am_shared_mmap_file_float_valgrind)
+       (SHMSIZE, VKI_PROT_READ|VKI_PROT_WRITE, fd, 0);
+    VG_(close)(fd);
+
+    if (sr_isError(res)) {
+       VG_(unlink)(shmfile);
+       return 0;
+    }
+    shmaddr = (char*) sr_Res(res);
+    shmh = (shm_header*) shmaddr;
+
+    for(i=0;i<8;i++)
+      shmh->magic[i] = magic[i];
+    shmh->size = SHMSIZE;
+    shmh->producer_64bit = (sizeof(long) == 8);
+    shmh->producer_initialized = 0;
+    shmh->consumer_attached = 0;
+    for(i=0;i<15;i++)
+      shmh->seg[i].offset = 0;
+
+    shmused = 256;
+
+    if (VG_(clo_verbosity) >1)
+      VG_(dmsg)("Event producer: created '%s', size %d.\n", shmfile, SHMSIZE);
+
+    attach_time = wtime();
+
+    return shmaddr;
+}
+
+void shm_startconsumer(char* exe, int start_consumer)
+{
+    Char pidstr[10];
+
+    VG_(sprintf)(pidstr, "%d", VG_(getpid)());
+    if (start_consumer) {
+        if (VG_(fork)() == 0) {	    
+            Char* argv[3] = { exe, pidstr, 0};
+            Char* argv_verb[4] = { exe, "-v", pidstr, 0};
+	    if (VG_(clo_verbosity) >1)
+	      VG_(execv)(exe, argv_verb);
+	    else
+	      VG_(execv)(exe, argv);
+	    VG_(dmsg)("ERROR: Can not run consumer '%s'.\n", exe);
+	    VG_(dmsg)("       Run manually with '%s %s'.\n", exe, pidstr);
+            VG_(exit)(1);
+        }
+    }
+    else
+        VG_(dmsg)("Run '%s %s' to start event consumer\n", exe, pidstr);
+}
+
+void shm_finish(void)
+{
+    if (!shmaddr) return;
+
+    VG_(am_munmap_valgrind)( (Addr)shmaddr, SHMSIZE);
+    shmaddr = 0;
+    //VG_(unlink)(shmfile);
+}
+
+char* shm_alloc_segment(Char* name, Int size)
+{
+    char* res;
+    int s, i;
+
+    if (!shmh) return 0;
+
+    size = (size | 63) +1;
+
+    if (shmused + size >= SHMSIZE)
+       VG_(tool_panic)("Out of SHM space.");
+
+    for(s=0;s<15;s++)
+      if (shmh->seg[s].offset == 0) break;
+    if (s==15)
+       VG_(tool_panic)("Out of SHM segment space.");
+
+    shmh->seg[s].offset = shmused;
+    shmh->seg[s].size = size;
+    for(i=0; name[i] && (i<7); i++) shmh->seg[s].name[i] = name[i];
+    for(; i<8; i++) shmh->seg[s].name[i] = 0;
+
+    if (VG_(clo_verbosity) >1)
+      VG_(dmsg)("Event producer: created seg '%s', size %d (seg# %d at %d).\n",
+		name, size, s, shmused);
+
+    res = shmaddr + shmused;
+    shmused += size;
+    return res;
+}
+
+/* shm is now initialized */
+void shm_initialized(void)
+{
+    if (shmaddr)
+	shmaddr[13] = 1;
+}
+
+#if 0
+Int shm_wait(void)
+{
+  volatile Char* w;
+
+  if (!shmaddr) return 0;
+  shmaddr[13] = 1;
+
+  VG_(printf)("Waiting for consumer to attach to SHM file '%s'...\n", shmfile);
+  w = shmaddr+15;
+  while(!*w);
+  VG_(printf)("Consumer attached.\n");
+
+  return 1;
+}
+#endif
+
+shm_rb* shm_alloc_rb(Char* name, int count, int size)
+{
+  char* b;
+  int s, i;
+  shm_rb* rb;
+  rb_header* h;
+
+  s = ((size-1) | 63) +1;
+  b = shm_alloc_segment(name, 64 + count * (64 + s));
+  if (!b) return 0;
+
+  rb = (shm_rb*) VG_(malloc)("shm_alloc_rb",
+			     sizeof(shm_rb) + count * sizeof(rb_chunk));
+  if (!rb) return 0; /* FIXME: free segment */
+
+  h = (rb_header*) b;
+  h->chunk_count = count;
+  h->chunk_size = s;
+  h->state0_offset = 64;
+  h->buffer0_offset = (count+1) * 64;
+
+  rb->header = h;
+  rb->name = name;
+  rb->fill_count = 0;
+  rb->event_count = 0;
+  rb->byte_count = 0;
+  rb->first = &(rb->chunk[0]);
+  for(i=0;i<count;i++) {
+    b[64 + 64*i] = RBSTATE_EMPTY;
+
+    rb->chunk[i].rb = rb;
+    rb->chunk[i].state = & b[64 + 64*i];
+    rb->chunk[i].buffer = & b[64*(count+1) + s * i];
+    rb->chunk[i].size = size;
+    rb->chunk[i].next = &(rb->chunk[ (i<count-1) ? i+1 : 0]);
+  }
+
+  return rb;
+}
+
+void shm_init_sending(rb_state* st, shm_rb* rb)
+{
+    rb_chunk* c = rb->first;
+    st->current = c;
+
+    tl_assert(*(c->state) == RBSTATE_EMPTY);
+
+    st->write_ptr = c->buffer + 4;
+    st->end_ptr = c->buffer + c->size;
+    st->event_count = 0;
+
+    if(0) VG_(printf)("Starting chunk at %p (offset 0x%x) with size %d bytes.\n",
+                      c->buffer,
+                      (int)(c->buffer - (unsigned char*) c->rb->header), c->size);
+}
+
+
+// called by start_event if buffer full
+rb_chunk* next_chunk(rb_state* st)
+{
+  rb_chunk* c = st->current;
+  int used = st->write_ptr - c->buffer;
+
+  tl_assert(st->end_ptr == c->buffer + c->size);
+  tl_assert2(used <= c->size,
+             "Used %d > size %d", used, c->size);
+  *(int*)(c->buffer) = used;
+  if (*(c->state) != RBSTATE_EMPTY)
+      VG_(tool_panic)("Filled non-empty chunck?");
+  c->rb->fill_count++;
+  c->rb->byte_count += used;
+  c->rb->event_count += st->event_count;
+
+  *(c->state) = RBSTATE_FULL;
+
+  if(0) VG_(printf)("Filled chunk at %p (offset 0x%x) with %d bytes.\n",
+                    c->buffer,
+                    (int)(c->buffer - (unsigned char*) c->rb->header), used);
+
+  c = c->next;
+  if (*(c->state) != RBSTATE_EMPTY) {
+      unsigned char* seg = (unsigned char*) c->rb->header;
+      if(0) VG_(printf)("Waiting for chunk at 0x%x (state at 0x%x).\n",
+			(int)(c->buffer - seg), (int)(c->state - seg));
+      double t = wtime();
+      while(*(c->state) != RBSTATE_EMPTY) {}
+      wait_time += wtime() - t;
+  }
+
+  st->current = c;
+  st->write_ptr = c->buffer + 4; // 4 bytes reserved for bytes used in chunk
+  st->end_ptr = c->buffer + c->size;
+  st->event_count = 0;
+
+  if(0) VG_(printf)("Starting chunk at %p (offset 0x%x) with size %d bytes.\n",
+                    c->buffer,
+                    (int)(c->buffer - (unsigned char*) c->rb->header), c->size);
+
+  return c;
+}
+
+void shm_close(rb_state* st)
+{
+    rb_chunk* c = st->current;
+    int used = st->write_ptr - c->buffer;
+
+    tl_assert(st->end_ptr == c->buffer + c->size);
+    tl_assert2(used <= c->size,
+               "Used %d > size %d", used, c->size);
+    *(int*)(c->buffer) = used;
+    if (*(c->state) != RBSTATE_EMPTY)
+        VG_(tool_panic)("Filled non-empty chunck?");
+    c->rb->fill_count++;
+    c->rb->byte_count += used;
+    c->rb->event_count += st->event_count;
+
+    *(c->state) = RBSTATE_FULLEND;
+
+    if(0) VG_(printf)("Filled last chunk at 0x%x with %d bytes.\n",
+                      (int)(c->buffer - (unsigned char*) c->rb->header), used);
+
+    if (VG_(clo_verbosity) <2) return;
+
+    double t = wtime() - attach_time;
+    double tt = t - wait_time;
+    int chunks_produced = c->rb->fill_count;
+    long events_produced = c->rb->event_count;
+    long bytes_produced = c->rb->byte_count;
+    double p = wait_time/t*100.0;
+    double t2 = wait_time;
+    double t3 = (double) events_produced / t / 1000000.0;
+    double t4 = (double) bytes_produced / t / 1000000.0;
+    double t5 = (double) events_produced / tt / 1000000.0;
+    double t6 = (double) bytes_produced / tt / 1000000.0;
+    VG_(dmsg)("Event producer (rb '%s') statistics:\n"
+              "  total %d.%03ds (active %d.%03ds, waiting %d.%03ds = %d.%02d%%)\n"
+              "  produced %d chunks, %ld events, %ld bytes\n"
+              "  troughput %d.%03d MEv/s, %d.%03d MB/s (without waiting %d.%1d MEv/s, %d.%1d MB/s)\n",
+              c->rb->name,
+              (int) t, (int)(1000.0 * (t - (int)t)),
+              (int) tt, (int)(1000.0 * (tt - (int)tt)),
+              (int) t2, (int)(1000.0 * (t2 - (int)t2)),
+              (int) p, (int)(100.0 * (p - (int)p)),
+              chunks_produced, events_produced, bytes_produced,
+              (int) t3, (int)(1000.0 * (t3 - (int)t3)),
+              (int) t4, (int)(1000.0 * (t4 - (int)t4)),
+              (int) t5, (int)(10.0 * (t5 - (int)t5)),
+              (int) t6, (int)(10.0 * (t6 - (int)t6)));
+}
diff --git a/mctracer/shm_vgprod.h b/mctracer/shm_vgprod.h
new file mode 100644
index 0000000..fd8e14f
--- /dev/null
+++ b/mctracer/shm_vgprod.h
@@ -0,0 +1,144 @@
+/* Shared memory event bridge (Valgrind side)
+ * Allows multiple, chunked ring buffers
+ *
+ * (C) 2011, Josef Weidendorfer
+ */
+
+#ifndef SHM_VGPROD_H
+#define SHM_VGPROD_H
+
+#include "pub_tool_libcassert.h"
+
+#include "shm_common.h"
+
+#define MAX_EVENTLEN 252
+
+typedef struct _rb_chunk rb_chunk;
+typedef struct _rb_state rb_state;
+typedef struct _shm_rb shm_rb;
+
+struct _rb_chunk {
+  shm_rb* rb;
+  volatile unsigned char* state;
+  unsigned char* buffer;
+  rb_chunk* next;
+  int size;
+};
+
+struct _shm_rb {
+  rb_header* header;
+  char* name;
+  int fill_count;
+  long event_count;
+  long byte_count;
+  rb_chunk* first;
+  rb_chunk chunk[0];
+};
+
+// Meant to be allocated by the user of the event bridge.
+struct _rb_state {
+    rb_chunk* current; // current chunk used
+    unsigned char* write_ptr;
+    unsigned char* end_ptr;
+
+    int event_count;   // for current chunk
+};
+
+char* shm_init(void);
+void shm_startconsumer(char* exe, int);
+
+void shm_finish(void);
+char* shm_alloc_segment(Char* name, Int size);
+void shm_initialized(void);
+
+/* Allocates a SHM segment. To write events, call shm_init_sending()
+ * and use start/end_event() afterwards */
+shm_rb* shm_alloc_rb(Char* name, int count, int size);
+
+/* Initialize the sending state to start with first buffer */
+void shm_init_sending(rb_state* st, shm_rb* rb);
+
+/* Set current chunk to FULL, and wait for next to allow to fill.
+ * This can block (uses spin loop for now) */
+rb_chunk* next_chunk(rb_state* st);
+
+/* Set current chunk to FULLEND */
+void shm_close(rb_state* st);
+
+/* allow for inlining */
+
+
+// call before start_event to check for space
+// (len must be 2 larger than event size)
+static inline
+void ensure_space(rb_state* st, int len)
+{
+    if (st->end_ptr - st->write_ptr < len)
+        next_chunk(st);
+}
+
+static inline
+char* start_event(rb_state* st, char tag, int len)
+{
+    unsigned char* wp;
+
+    st->event_count++;
+    wp = st->write_ptr;
+
+    if(0) VG_(printf)("Starting event %d, len %2d at %p, offset %d.\n",
+                      tag, len, wp+2,
+                      (int)(wp+2 - st->current->buffer));
+
+    tl_assert2(len <= MAX_EVENTLEN, "length is %d", len);
+    wp[0] = len+2;
+    wp[1] = tag;
+
+    return wp + 2;
+}
+
+// update length of event after start_event()
+static inline
+void update_length(rb_state* st, int len)
+{
+    char* wp = st->write_ptr;
+
+    tl_assert2(len <= MAX_EVENTLEN, "length is %d", len);
+    *wp = len+2;
+}
+
+// finish event after start_event()
+static inline
+char* end_event(rb_state* st)
+{
+    unsigned char* wp = st->write_ptr;
+    st->write_ptr += *wp;
+
+    return wp;
+}
+
+// call if len is known (no need to call end_event afterwards)
+static inline
+char* write_event(rb_state* st, char tag, int len)
+{
+    char* b;
+
+    ensure_space(st, len+2);
+    b = start_event(st, tag, len);
+    st->write_ptr += len+2;
+
+    return b;
+}
+
+// same as above, but space already ensured
+static inline
+char* send_event(rb_state* st, char tag, int len)
+{
+    char* b;
+
+    b = start_event(st, tag, len);
+    st->write_ptr += len+2;
+
+    return b;
+}
+
+#endif
diff --git a/mctracer/tests/Makefile.am b/mctracer/tests/Makefile.am
new file mode 100644
index 0000000..e16c9a1
--- /dev/null
+++ b/mctracer/tests/Makefile.am
@@ -0,0 +1,3 @@
+dist_noinst_SCRIPTS = filter_stderr
+
+EXTRA_DIST = true.stderr.exp true.vgtest
diff --git a/mctracer/tests/filter_stderr b/mctracer/tests/filter_stderr
new file mode 100644
index 0000000..cba3fed
--- /dev/null
+++ b/mctracer/tests/filter_stderr
@@ -0,0 +1,14 @@
+#! /bin/sh
+
+dir=`dirname $0`
+
+$dir/../../tests/filter_stderr_basic    |
+
+# Remove "Lackey, ..." line and the following copyright line.
+sed "/^Lackey, an example Valgrind tool/ , /./ d" |
+
+# Filter all the numbers.
+../../tests/filter_numbers |
+
+# Replace "call" with "calls"
+sed "s/ call / calls /"
diff --git a/mctracer/tests/true.stderr.exp b/mctracer/tests/true.stderr.exp
new file mode 100644
index 0000000..9a14875
--- /dev/null
+++ b/mctracer/tests/true.stderr.exp
@@ -0,0 +1,20 @@
+
+
+Counted ... calls to main()
+
+Jccs:
+  total:         ...
+  taken:         ... ( ...%)
+
+Executed:
+  SBs entered:   ...
+  SBs completed: ...
+  guest instrs:  ...
+  IRStmts:       ...
+
+Ratios:
+  guest instrs : SB entered  = ... : ...
+       IRStmts : SB entered  = ... : ...
+       IRStmts : guest instr = ... : ...
+
+Exit code:       ...
diff --git a/mctracer/tests/true.vgtest b/mctracer/tests/true.vgtest
new file mode 100644
index 0000000..24fc0a4
--- /dev/null
+++ b/mctracer/tests/true.vgtest
@@ -0,0 +1 @@
+prog: ../../tests/true
diff --git a/mctracer/tr_consumer.c b/mctracer/tr_consumer.c
new file mode 100644
index 0000000..e828056
--- /dev/null
+++ b/mctracer/tr_consumer.c
@@ -0,0 +1,66 @@
+/*
+ * Event consumer for mctracer: simple event dump to stdout.
+ * For ETI @ TUM, (C) 2011 Josef Weidendorfer
+ */
+
+#include "shm_consumer.h"
+
+/* hack: only works when event producer uses same architecture */
+typedef unsigned long Addr;
+
+#include "tr_shmevents.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+
+void run_tid(ev_run_tid* e)
+{
+  printf("Thread %d\n", e->tid);
+}
+
+void data_read(ev_data_read* e)
+{
+  printf("Data Read %p,%d\n", e->addr, e->len);
+}
+
+void data_write(ev_data_write* e)
+{
+  printf("Data Write %p,%d\n", e->addr, e->len);
+}
+
+int main(int argc, char* argv[])
+{
+    shm_buf* buf;
+    shm_rb* rb;
+    rb_chunk* chunk;
+    tr_event* e;
+
+    buf = shm_init(argc, argv);
+    rb = open_rb(buf, "tr_main");
+    if (!rb) {
+      printf("Cannot open ring buffer 'tr_main'\n");
+      exit(1);
+    }
+
+    chunk = open_first(rb);
+    while( (e = (tr_event*) next_event(&chunk)) ) {
+      switch(e->tag) {
+      case TR_RUN_TID:
+	run_tid(&(e->run_tid));
+	break;
+      case TR_DATA_READ:
+	data_read(&(e->data_read));
+	break;
+      case TR_DATA_WRITE:
+	data_write(&(e->data_write));
+	break;
+      default:
+	printf(" Unknown event tag %d\n", e->tag);
+	abort();
+	break;
+      }
+    }
+
+    return 0;
+}
diff --git a/mctracer/tr_main.c b/mctracer/tr_main.c
new file mode 100644
index 0000000..07176c0
--- /dev/null
+++ b/mctracer/tr_main.c
@@ -0,0 +1,567 @@
+/*--------------------------------------------------------------------*/
+/*--- An memtracer Valgrind tool.                        tr_main.c ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of McTracer, a Valgrind tool for memory tracing.
+   It is mainly a copy of the Lackey example Valgrind tool.
+
+   Written for ETI @ TUM, (C) 2010-2011 Josef Weidendorfer.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307, USA.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+
+#include "pub_tool_basics.h"
+#include "pub_tool_tooliface.h"
+#include "pub_tool_libcassert.h"
+#include "pub_tool_libcprint.h"
+#include "pub_tool_debuginfo.h"
+#include "pub_tool_libcbase.h"
+#include "pub_tool_options.h"
+#include "pub_tool_machine.h"     // VG_(fnptr_to_fnentry)
+#include "pub_tool_threadstate.h"
+
+#include "shm_vgprod.h"
+#include "tr_shmevents.h"
+
+#include "mctracer.h"
+
+static Bool mt_tracing_state = False;
+
+/*------------------------------------------------------------*/
+/*--- Command line options                                 ---*/
+/*------------------------------------------------------------*/
+
+
+/* The name of the function at which tracing should start.
+ * Override with command line option --fnstart.
+ * If empty (default), starts tracing when entering "main".
+ */
+static Char* clo_fnstart = "main";
+
+/* The name of the event consumer binary */
+static Char* clo_consumer = "./tr-consumer";
+
+/* Should we start the event consumer? */
+static Bool  clo_run_consumer = True;
+
+static Bool mt_process_cmd_line_option(Char* arg)
+{
+   if      VG_STR_CLO(arg, "--fnstart", clo_fnstart) {}
+   else if VG_STR_CLO(arg, "--consumer", clo_consumer) {}
+   else if VG_BOOL_CLO(arg, "--run-consumer", clo_run_consumer) {}
+   else
+      return False;
+   
+   tl_assert(clo_fnstart);
+   tl_assert(clo_consumer);
+   return True;
+}
+
+static void mt_print_usage(void)
+{  
+   VG_(printf)(
+"    --fnstart=<name>        start tracing when entering this function [%s]\n"
+"    --consumer=<name>       event consumer binary to start [%s]\n"
+"    --run-consumer=yes|no   run consumer (use no for debugging) [yes]\n",
+clo_fnstart, clo_consumer
+   );
+}
+
+static void mt_print_debug_usage(void)
+{  
+   VG_(printf)(
+"    (none)\n"
+   );
+}
+
+/*------------------------------------------------------------*/
+/*--- Stuff for --basic-counts                             ---*/
+/*------------------------------------------------------------*/
+
+static void start_tracing(void)
+{
+   // start tracing at function specified with --fnstart (defaults to "main")
+   mt_tracing_state = True;
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Stuff for memory access tracing                      ---*/
+/*------------------------------------------------------------*/
+
+#define MAX_DSIZE    512
+
+typedef
+   IRExpr 
+   IRAtom;
+
+typedef 
+   enum { Event_Ir, Event_Dr, Event_Dw }
+   EventKind;
+
+typedef
+   struct {
+      EventKind  ekind;
+      IRAtom*    addr;
+      Int        size;
+   }
+   Event;
+
+/* Up to this many unnotified events are allowed.  Must be at least two,
+   so that reads and writes to the same address can be merged into a modify.
+   Beyond that, larger numbers just potentially induce more spilling due to
+   extending live ranges of address temporaries. */
+#define N_EVENTS 4
+
+/* Maintain an ordered list of memory events which are outstanding, in
+   the sense that no IR has yet been generated to do the relevant
+   helper calls.  The SB is scanned top to bottom and memory events
+   are added to the end of the list, merging with the most recent
+   notified event where possible (Dw immediately following Dr and
+   having the same size and EA can be merged).
+
+   This merging is done so that for architectures which have
+   load-op-store instructions (x86, amd64), the instr is treated as if
+   it makes just one memory reference (a modify), rather than two (a
+   read followed by a write at the same address).
+
+   At various points the list will need to be flushed, that is, IR
+   generated from it.  That must happen before any possible exit from
+   the block (the end, or an IRStmt_Exit).  Flushing also takes place
+   when there is no space to add a new event.
+
+   If we require the simulation statistics to be up to date with
+   respect to possible memory exceptions, then the list would have to
+   be flushed before each memory reference.  That's a pain so we don't
+   bother.
+
+   Flushing the list consists of walking it start to end and emitting
+   instrumentation IR for each event, in the order in which they
+   appear. */
+
+static Event events[N_EVENTS];
+static Int   events_used = 0;
+
+static ThreadId last_trace_tid = -1;
+static ThreadId last_seen_tid = -1;
+
+/* Event bridge writing state */
+static rb_state bridge_state;
+
+static void print_trace_tid(void)
+{
+    if (last_trace_tid != last_seen_tid) {
+	last_trace_tid = last_seen_tid;
+
+	ev_run_tid* e;
+	e = (ev_run_tid*) write_event(&bridge_state, TR_RUN_TID,
+				      sizeof(ev_run_tid));
+	e->tid = last_trace_tid;
+    }
+}
+
+static VG_REGPARM(2) void trace_instr(Addr addr, SizeT size)
+{
+//    VG_(printf)("I %08lx,%lu\n", addr, size);
+}
+
+static VG_REGPARM(2) void trace_load(Addr addr, SizeT size)
+{
+    if (mt_tracing_state) {
+	print_trace_tid();
+	
+	ev_data_read* e;
+	e = (ev_data_read*) write_event(&bridge_state, TR_DATA_READ,
+					sizeof(ev_data_read));
+	e->addr = addr;
+	e->len  = size;
+    }
+}
+
+static VG_REGPARM(2) void trace_store(Addr addr, SizeT size)
+{
+    if (mt_tracing_state) {
+	print_trace_tid();
+
+	ev_data_write* e;
+	e = (ev_data_write*) write_event(&bridge_state, TR_DATA_WRITE,
+					 sizeof(ev_data_write));
+	e->addr = addr;
+	e->len  = size;
+    }
+}
+
+
+
+static void flushEvents(IRSB* sb)
+{
+   Int        i;
+   Char*      helperName;
+   void*      helperAddr;
+   IRExpr**   argv;
+   IRDirty*   di;
+   Event*     ev;
+
+   for (i = 0; i < events_used; i++) {
+
+      ev = &events[i];
+      
+      // Decide on helper fn to call and args to pass it.
+      switch (ev->ekind) {
+         case Event_Ir: helperName = "trace_instr";
+                        helperAddr =  trace_instr;  break;
+
+         case Event_Dr: helperName = "trace_load";
+                        helperAddr =  trace_load;   break;
+
+         case Event_Dw: helperName = "trace_store";
+                        helperAddr =  trace_store;  break;
+
+         default:
+            tl_assert(0);
+      }
+
+      // Add the helper.
+      argv = mkIRExprVec_2( ev->addr, mkIRExpr_HWord( ev->size ) );
+      di   = unsafeIRDirty_0_N( /*regparms*/2, 
+                                helperName, VG_(fnptr_to_fnentry)( helperAddr ),
+                                argv );
+      addStmtToIRSB( sb, IRStmt_Dirty(di) );
+   }
+
+   events_used = 0;
+}
+
+// WARNING:  If you aren't interested in instruction reads, you can omit the
+// code that adds calls to trace_instr() in flushEvents().  However, you
+// must still call this function, addEvent_Ir() -- it is necessary to add
+// the Ir events to the events list so that merging of paired load/store
+// events into modify events works correctly.
+static void addEvent_Ir ( IRSB* sb, IRAtom* iaddr, UInt isize )
+{
+   Event* evt;
+   tl_assert( (VG_MIN_INSTR_SZB <= isize && isize <= VG_MAX_INSTR_SZB)
+            || VG_CLREQ_SZB == isize );
+   if (events_used == N_EVENTS)
+      flushEvents(sb);
+   tl_assert(events_used >= 0 && events_used < N_EVENTS);
+   evt = &events[events_used];
+   evt->ekind = Event_Ir;
+   evt->addr  = iaddr;
+   evt->size  = isize;
+   events_used++;
+}
+
+static
+void addEvent_Dr ( IRSB* sb, IRAtom* daddr, Int dsize )
+{
+   Event* evt;
+   tl_assert(isIRAtom(daddr));
+   tl_assert(dsize >= 1 && dsize <= MAX_DSIZE);
+   if (events_used == N_EVENTS)
+      flushEvents(sb);
+   tl_assert(events_used >= 0 && events_used < N_EVENTS);
+   evt = &events[events_used];
+   evt->ekind = Event_Dr;
+   evt->addr  = daddr;
+   evt->size  = dsize;
+   events_used++;
+}
+
+static
+void addEvent_Dw ( IRSB* sb, IRAtom* daddr, Int dsize )
+{
+   Event* evt;
+   tl_assert(isIRAtom(daddr));
+   tl_assert(dsize >= 1 && dsize <= MAX_DSIZE);
+
+   if (events_used == N_EVENTS)
+      flushEvents(sb);
+   tl_assert(events_used >= 0 && events_used < N_EVENTS);
+   evt = &events[events_used];
+   evt->ekind = Event_Dw;
+   evt->size  = dsize;
+   evt->addr  = daddr;
+   events_used++;
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Client requests                                      ---*/
+/*------------------------------------------------------------*/
+
+
+static
+Bool mt_handle_client_request(ThreadId tid, UWord *args, UWord *ret)
+{
+   if (!VG_IS_TOOL_USERREQ('M','T',args[0]))
+       return False;
+
+   last_seen_tid = tid;
+
+   switch(args[0]) {
+   case VG_USERREQ__PRINT:
+       if (mt_tracing_state) {
+	   print_trace_tid();
+	   VG_(printf)("P %s\n", (Char*)args[1]);
+       }
+       *ret = 0;                 /* meaningless */
+       break;
+
+   case VG_USERREQ__PRINTA:
+       if (mt_tracing_state) {
+	   print_trace_tid();
+	   VG_(printf)("A %08lx\n", (Addr)args[1]);
+       }
+       *ret = 0;                 /* meaningless */
+       break;
+
+   case VG_USERREQ__PRINTU:
+       if (mt_tracing_state) {
+	   print_trace_tid();
+	   VG_(printf)("U %lu\n", (UWord)args[1]);
+       }
+       *ret = 0;                 /* meaningless */
+       break;
+
+   case VG_USERREQ__TRACING:
+       mt_tracing_state = (Bool) args[1];
+       *ret = 0;                 /* meaningless */
+       break;
+
+   default:
+      return False;
+   }
+
+   return True;
+}
+
+static void mt_start_client_code_callback ( ThreadId tid, ULong blocks_done )
+{
+   last_seen_tid = tid;
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Basic tool functions                                 ---*/
+/*------------------------------------------------------------*/
+
+static void mt_post_clo_init(void)
+{
+   mt_tracing_state = (clo_fnstart[0] == 0);
+
+   shm_init();
+   shm_rb* rb = shm_alloc_rb("tr_main", 4, 8192);
+   if (!rb)
+     VG_(tool_panic)("Cannot create event bridge ring buffer.");
+   shm_init_sending(&bridge_state, rb);
+   shm_initialized();
+   shm_startconsumer(clo_consumer, clo_run_consumer);
+}
+
+static
+IRSB* mt_instrument ( VgCallbackClosure* closure,
+                      IRSB* sbIn, 
+                      VexGuestLayout* layout, 
+                      VexGuestExtents* vge,
+                      IRType gWordTy, IRType hWordTy )
+{
+   IRDirty*   di;
+   Int        i;
+   IRSB*      sbOut;
+   Char       fnname[100];
+   IRTypeEnv* tyenv = sbIn->tyenv;
+
+   if (gWordTy != hWordTy) {
+      /* We don't currently support this case. */
+      VG_(tool_panic)("host/guest word size mismatch");
+   }
+
+   /* Set up SB */
+   sbOut = deepCopyIRSBExceptStmts(sbIn);
+
+   // Copy verbatim any IR preamble preceding the first IMark
+   i = 0;
+   while (i < sbIn->stmts_used && sbIn->stmts[i]->tag != Ist_IMark) {
+      addStmtToIRSB( sbOut, sbIn->stmts[i] );
+      i++;
+   }
+
+   events_used = 0;
+
+   for (/*use current i*/; i < sbIn->stmts_used; i++) {
+      IRStmt* st = sbIn->stmts[i];
+      if (!st || st->tag == Ist_NoOp) continue;
+
+      switch (st->tag) {
+         case Ist_NoOp:
+         case Ist_AbiHint:
+         case Ist_Put:
+         case Ist_PutI:
+         case Ist_MBE:
+	     addStmtToIRSB( sbOut, st );
+	     break;
+
+         case Ist_IMark:
+
+	     /* An unconditional branch to a known destination in the
+	      * guest's instructions can be represented, in the IRSB to
+	      * instrument, by the VEX statements that are the
+	      * translation of that known destination. This feature is
+	      * called 'SB chasing' and can be influenced by command
+	      * line option --vex-guest-chase-thresh.
+	      *
+	      * To get an accurate count of the calls to a specific
+	      * function, taking SB chasing into account, we need to
+	      * check for each guest instruction (Ist_IMark) if it is
+	      * the entry point of a function.
+	      */
+	     tl_assert(clo_fnstart);
+	     if (clo_fnstart[0] &&
+		 VG_(get_fnname_if_entry)(st->Ist.IMark.addr, 
+					  fnname, sizeof(fnname))
+		 && 0 == VG_(strcmp)(fnname, clo_fnstart)) {
+		 di = unsafeIRDirty_0_N( 
+		     0, "start_tracing", 
+		     VG_(fnptr_to_fnentry)( &start_tracing ),
+		     mkIRExprVec_0() );
+		 addStmtToIRSB( sbOut, IRStmt_Dirty(di) );
+	     }
+
+	     // WARNING: do not remove this function call, even if you
+	     // aren't interested in instruction reads.  See the comment
+	     // above the function itself for more detail.
+	     addEvent_Ir( sbOut, mkIRExpr_HWord( (HWord)st->Ist.IMark.addr ),
+			  st->Ist.IMark.len );
+	     addStmtToIRSB( sbOut, st );
+	     break;
+
+	  case Ist_WrTmp:
+              {
+		  IRExpr* data = st->Ist.WrTmp.data;
+		  if (data->tag == Iex_Load) {
+		      addEvent_Dr( sbOut, data->Iex.Load.addr,
+				   sizeofIRType(data->Iex.Load.ty) );
+		  }
+	      }
+	      addStmtToIRSB( sbOut, st );
+	      break;
+
+         case Ist_Store:
+	     {
+		 IRExpr* data  = st->Ist.Store.data;
+		 addEvent_Dw( sbOut, st->Ist.Store.addr,
+			      sizeofIRType(typeOfIRExpr(tyenv, data)) );
+	     }
+	     addStmtToIRSB( sbOut, st );
+	     break;
+
+         case Ist_Dirty:
+	     {
+		 
+		 Int      dsize;
+		 IRDirty* d = st->Ist.Dirty.details;
+		 if (d->mFx != Ifx_None) {
+		     // This dirty helper accesses memory.  Collect the details.
+		     tl_assert(d->mAddr != NULL);
+		     tl_assert(d->mSize != 0);
+		     dsize = d->mSize;
+		     if (d->mFx == Ifx_Read || d->mFx == Ifx_Modify)
+			 addEvent_Dr( sbOut, d->mAddr, dsize );
+		     if (d->mFx == Ifx_Write || d->mFx == Ifx_Modify)
+			 addEvent_Dw( sbOut, d->mAddr, dsize );
+		 } else {
+		     tl_assert(d->mAddr == NULL);
+		     tl_assert(d->mSize == 0);
+		 }
+
+		 addStmtToIRSB( sbOut, st );
+		 break;
+	     }
+
+         case Ist_CAS:
+	     {
+		 /* We treat it as a read and a write of the location.  I
+		    think that is the same behaviour as it was before IRCAS
+		    was introduced, since prior to that point, the Vex
+		    front ends would translate a lock-prefixed instruction
+		    into a (normal) read followed by a (normal) write. */
+
+		 Int    dataSize;
+		 IRCAS* cas = st->Ist.CAS.details;
+		 tl_assert(cas->addr != NULL);
+		 tl_assert(cas->dataLo != NULL);
+		 dataSize = sizeofIRType(typeOfIRExpr(tyenv, cas->dataLo));
+		 if (cas->dataHi != NULL)
+		     dataSize *= 2; /* since it's a doubleword-CAS */
+		 addEvent_Dr( sbOut, cas->addr, dataSize );
+		 addEvent_Dw( sbOut, cas->addr, dataSize );
+		 
+		 addStmtToIRSB( sbOut, st );
+		 break;
+	     }
+
+         case Ist_Exit:
+	     flushEvents(sbOut);
+	     addStmtToIRSB( sbOut, st );      // Original statement
+	     break;
+
+         default:
+	     tl_assert(0);
+      }
+   }
+
+   /* At the end of the sbIn.  Flush outstandings. */
+   flushEvents(sbOut);
+
+   return sbOut;
+}
+
+static void mt_fini(Int exitcode)
+{
+    shm_close(&bridge_state);
+    shm_finish();
+}
+
+static void mt_pre_clo_init(void)
+{
+   VG_(details_name)            ("McTracer");
+   VG_(details_version)         (NULL);
+   VG_(details_description)     ("an memory tracer tool");
+   VG_(details_copyright_author)(
+      "Copyright (C) 2002-2011, and GNU GPL'd, by NN & JW.");
+   VG_(details_bug_reports_to)  (VG_BUGS_TO);
+   VG_(details_avg_translation_sizeB) ( 200 );
+
+   VG_(basic_tool_funcs)          (mt_post_clo_init,
+                                   mt_instrument,
+                                   mt_fini);
+   VG_(needs_command_line_options)(mt_process_cmd_line_option,
+                                   mt_print_usage,
+                                   mt_print_debug_usage);
+   VG_(needs_client_requests)     (mt_handle_client_request);
+   VG_(track_start_client_code)   (mt_start_client_code_callback);
+}
+
+VG_DETERMINE_INTERFACE_VERSION(mt_pre_clo_init)
+
+/*--------------------------------------------------------------------*/
+/*--- end                                                tr_main.c ---*/
+/*--------------------------------------------------------------------*/
diff --git a/mctracer/tr_shmevents.h b/mctracer/tr_shmevents.h
new file mode 100644
index 0000000..7f0d267
--- /dev/null
+++ b/mctracer/tr_shmevents.h
@@ -0,0 +1,49 @@
+/*
+ * McTracer: memory event tracer via event bridge.
+ * Definition of used event types.
+ *
+ * For ETI @ TUM, (C) 2011 Josef Weidendorfer
+ */
+
+#ifndef TR_SHMEVENTS_H
+#define TR_SHMEVENTS_H
+
+#define TR_RUN_TID           1
+#define TR_DATA_READ         2
+#define TR_DATA_WRITE        3
+
+typedef struct _tr_event tr_event;
+
+#pragma pack(push)
+#pragma pack(1)
+
+// tag TR_RUN_TID
+typedef struct {
+  int tid;
+} ev_run_tid;
+
+// tag TR_DATA_READ
+typedef struct {
+  Addr addr;
+  char len;
+} ev_data_read;
+
+// tag TR_DATA_WRITE
+typedef struct {
+  Addr addr;
+  char len;
+} ev_data_write;
+
+struct _tr_event {
+  /* Event header */
+  unsigned char len;
+  unsigned char tag;
+  union {
+    ev_run_tid     run_tid;
+    ev_data_read   data_read;
+    ev_data_write  data_write;
+  };
+};
+#pragma pack(pop)
+
+#endif
-- 
1.7.7.1.475.g997a1

