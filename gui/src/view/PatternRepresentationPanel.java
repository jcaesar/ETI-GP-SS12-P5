/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package view;

import data.RelativeJump;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.util.List;

/**
 *
 * @author Philip Becker-Ehmck
 */
public class PatternRepresentationPanel extends javax.swing.JPanel {

    private final List<RelativeJump> jumps;
    private final int ARR_SIZE = 4;

    /**
     * Creates new form PatternRepresentationPanel
     */
    public PatternRepresentationPanel(List<RelativeJump> jumps) {
        initComponents();
        this.jumps = jumps;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));
        setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        setMaximumSize(new java.awt.Dimension(120, 120));
        setMinimumSize(new java.awt.Dimension(120, 120));
        setPreferredSize(new java.awt.Dimension(120, 120));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 238, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 238, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    /**
     *
     * @param g
     */
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Antialiasing on for smother graphics
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);

        // stores current x,y position while going through the pattern
        int x = 0;
        int y = 0;
        // store minimal and maximal x,y value to determine the boundaries of the system
        double x_max = 0.01;
        double x_min = -0.01;
        double y_max = 0.01;
        double y_min = -0.01;

        // determine minimal and maximal x,y values while going through the pattern
        for (RelativeJump jump : jumps) {
            x += jump.getX_move();
            y += jump.getY_move();

            // update max/min values if necessary
            if (x > x_max) {
                x_max = x;
            } else if (x < x_min) {
                x_min = x;
            }
            if (y > y_max) {
                y_max = y;
            } else if (y < y_min) {
                y_min = y;
            }
        }

        // overall movement in x and y direction
        double x_overall_max = x_max + Math.abs(x_min);
        double y_overall_max = y_max + Math.abs(y_min);

        // Scale both axes independently
        double scaling_x = 90.0 / x_overall_max;
        double scaling_y = 90.0 / y_overall_max;

        // draw a black startpoint
        g.setColor(new Color(0, 0, 0));
        g.drawRect(10 + (int) (((double) Math.abs(x_min) / (double) (Math.abs(x_min) + x_max)) * 100) - 1,
                10 + (int) (((double) Math.abs(y_min) / (double) (Math.abs(y_min) + y_max)) * 100) - 1,
                2, 2);
        g.fillRect(10 + (int) (((double) Math.abs(x_min) / (double) (Math.abs(x_min) + x_max)) * 100) - 1,
                10 + (int) (((double) Math.abs(y_min) / (double) (Math.abs(y_min) + y_max)) * 100) - 1,
                2, 2);

        // reset the variables
        int x_old = 0;
        int y_old = 0;
        x = 0;
        y = 0;
        // draw the actual pattern
        for (RelativeJump jump : jumps) {
            x_old = x;
            y_old = y;
            x += jump.getX_move();
            y += jump.getY_move();
           
            g.setColor(calcColor((double) jump.getHits() / (double) (jump.getHits() + jump.getMisses()) * 100));

            drawArrow(g, (int) (x_old * scaling_x) + 10 + (int) (((double) Math.abs(x_min) / (double) (Math.abs(x_min) + x_max)) * 100),
                    (int) (y_old * scaling_y) + 10 + (int) (((double) Math.abs(y_min) / (double) (Math.abs(y_min) + y_max)) * 100),
                    (int) (x * scaling_x) + 10 + (int) (((double) Math.abs(x_min) / (double) (Math.abs(x_min) + x_max)) * 100),
                    (int) (y * scaling_y) + 10 + (int) (((double) Math.abs(y_min) / (double) (Math.abs(y_min) + y_max)) * 100));
        }
    }

    /*
     * Determines the color of the arrow according to the success rate 100 %
     * green - 0 % red
     */
    private Color calcColor(double rate) {
        return new Color((int) (255 * (100 - rate)) / 100, (int) (255 * rate) / 100, 0);
    }

    /**
     *
     * @param g1
     * @param x1 x-coordinate of the startpoint
     * @param y1 y-coordinate of the startpoint
     * @param x2 x-coordinate of the endpoint
     * @param y2 y-coordinate of the endpoint
     */
    private void drawArrow(Graphics g1, int x1, int y1, int x2, int y2) {
        Graphics2D g = (Graphics2D) g1.create();

        double dx = x2 - x1, dy = y2 - y1;
        double angle = Math.atan2(dy, dx);
        int len = (int) Math.sqrt(dx * dx + dy * dy);
        AffineTransform at = AffineTransform.getTranslateInstance(x1, y1);
        at.concatenate(AffineTransform.getRotateInstance(angle));
        g.transform(at);

        g.setStroke(new BasicStroke(1));
        // Draw horizontal arrow starting in (0, 0)
        g.drawLine(0, 0, len - 1, 0);
        g.fillPolygon(new int[]{len, len - ARR_SIZE, len - ARR_SIZE, len},
                new int[]{0, -ARR_SIZE, ARR_SIZE, 0}, 4);
    }
}
